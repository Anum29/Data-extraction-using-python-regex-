# -*- coding: utf-8 -*-
"""Data Pipeline-Regex-Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sb6P2Lq1HtnP-qK3k2MWf6VzbiztscIh
"""

import re

def concatenate_elements_after_index(arr, start_index):
    # Concatenate elements in the array from the given start_index to the end
    if 0 <= start_index < len(arr):
        concatenated_string = ' '.join(arr[start_index:])
        return concatenated_string
    return None  # Return None if start_index is out of bounds

def concatenate_until_space(arr):
    # Concatenate elements in the array until a space is encountered
    concatenated_string = ''
    for i, element in enumerate(arr):
        concatenated_string += element
        concatenated_string += ' '
        if element.startswith(' '):
            # Remove the last index value from the concatenated string
            concatenated_string = concatenated_string[:-(len(element)+1)]
            return i, concatenated_string.strip()
    return None, concatenated_string

# Read text data from the file 'AK2.txt'
with open('AK2.txt', 'r') as file:
    data_text = file.read()

# Split the text into chunks based on '-----'
chunks = re.split('-{5,}', data_text)

# Remove empty chunks
chunks = [chunk.strip() for chunk in chunks if chunk.strip()]

i = 0
# Iterate through chunks and extract information
for chunk in chunks:
    i = i + 1
    # Use regular expression to find text after 'Rates Fringes'
    pattern = re.compile(r'Rates\s+Fringes\s+([\s\S]+)')
    matches = pattern.search(chunk)

    if matches:
        selected_text = matches.group(1)

        # Replace certain patterns in the selected text
        selected_text = selected_text.replace('+a+b', '%')
        selected_text = selected_text.replace('+a', '%%')

        # Use regular expression to extract information from the selected text
        pattern = re.compile(r'^([\s\S]+?)\.{2}\$\s*(\d+\.\d{2})\s*([\d%.+\s]+)$', re.MULTILINE)
        matches = pattern.findall(selected_text)

        for match in matches:
            text, rate, fringe = match

            # Check for commas in the extracted text
            comma_pattern = re.compile(r',')
            commas_found = comma_pattern.findall(text)

            if(len(commas_found)>1 and not text.startswith(' ')):
                # Case 1: Extract job title and category if text has brackets and commas
                pattern = re.compile(r'\(([^)]+)\)')
                matches = pattern.findall(text)

                if(len(matches) >= 1):
                    job_title = re.sub(r'\.+', '', text)
                    refined_job_title = re.sub(r'\([^)]*\)\.*\s*', '', job_title)
                    category = matches[0]
                    print("\njob title:", refined_job_title, "\nrate:",  rate, "\nfringe:", fringe, "\ncategory:", category, "\n\n")
                else:
                    # Case 2: Treat as job title with no category if no brackets
                    job_title = re.sub(r'\.+', '', text)
                    refined_job_title = re.sub(r'\([^)]*\)\.*\s*', '', job_title)
                    category = " "
                    print("\njob title:", refined_job_title, "\nrate:",  rate, "\nfringe:", fringe, "\ncategory:", category, "\n\n")

            else:
                # Case 3: Handle job titles with multiple categories
                category = re.sub(r'\.+', '', text)
                pattern = re.compile(r'^(.*?)(?:\n|$)', re.MULTILINE)
                matches = pattern.findall(category)

                if matches:
                    results = [match.strip() for match in matches if match.strip()]
                else:
                    print("No matches found.")

                prev = ""
                count_empty = 0
                empty_index = 0
                for i, element in enumerate(matches):
                    if element == '  ' or element == '\n':
                        count_empty += 1
                        empty_index = i
                    prev = element

                if(len(matches)>=2):
                    if(("CLASSIFICATIONS" in text) and count_empty>=5):
                        # Concatenate job title from the remaining categories
                        index, concatenated_result = concatenate_until_space(matches[(empty_index+1):])
                        refined_job_title = concatenated_result
                        category = results[-1]
                        print("\njob title:", refined_job_title, "\nrate:",  rate, "\nfringe:", fringe, "\ncategory:", category, "\n\n")

                    elif(not matches[0].startswith(' ')):
                        # Concatenate job title from the categories
                        index, concatenated_result = concatenate_until_space(matches)
                        if (index is not None):
                            job_title = concatenated_result
                            refined_job_title = job_title
                            category = concatenate_elements_after_index(results, index)
                        else:
                            job_title = concatenated_result
                            refined_job_title = job_title
                            category = ""
                        print("\njob title:", refined_job_title, "\nrate:",  rate, "\nfringe:", fringe, "\ncategory:", category, "\n\n")

                    elif ((len(matches) == 2 and matches[0].startswith(' ') and matches[1].startswith(' '))):
                        # Handle cases with two categories
                        spaces_in_first_index = len(matches[0]) - len(matches[0].lstrip())
                        spaces_in_second_index = len(matches[1]) - len(matches[1].lstrip())
                        if spaces_in_first_index == spaces_in_second_index:
                            category = matches[0] + matches[1]
                            print("\njob title:", job_title, "\nrate:",  rate, "\nfringe:", fringe, "\ncategory:", category, "\n\n")
                        else:
                            job_title = re.sub(r'\([^)]*\)\.*\s*', '', matches[0])
                            refined_job_title = re.sub(r'\([^)]*\)\.*\s*', '', job_title)
                            category = matches[1]
                            print("\njob title:", job_title, "\nrate:",  rate, "\nfringe:", fringe, "\ncategory:", category, "\n\n")

                    elif (all(s.startswith(' ') for s in matches)):
                        # Concatenate job title and category from the categories
                        refined_job_title = re.sub(r'\([^)]*\)\.*\s*', '', job_title)
                        category = concatenate_elements_after_index(results, 0)
                        print("\njob title:", refined_job_title, "\nrate:",  rate, "\nfringe:", fringe, "\ncategory:", category, "\n\n")

                elif (matches[0].startswith(' ')) :
                    # Concatenate job title and category from the categories
                    category = concatenate_elements_after_index(results, 0)
                    print("\n job title:", refined_job_title, "\nrate:",  rate, "\nfringe:", fringe, "\ncategory:", category, "\n\n")

                else:
                    # Case 4: Single word job titles
                    job_title = re.sub(r'\.+', '', text)
                    category = ""
                    refined_job_title = re.sub(r'\([^)]*\)\.*\s*', '', job_title)
                    print("\njob title:", refined_job_title, "\nrate:",  rate, "\nfringe:", fringe, "\ncategory:", category, "\n\n")